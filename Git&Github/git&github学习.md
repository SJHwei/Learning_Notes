#### 一. 学习大纲

![](D:\git&github-figure\1.png)



#### 二. 版本控制

**1. [版本控制工具应该具备的功能]()**

1. **协同修改** :
   * 多人并行不悖的修改服务器端的同一个文件.
2. **数据备份** :
   * 不仅保存目录和文件的当前状态, 还能够保存每一个提交过的历史状态.
3. **版本管理** :
   * 在保存每一个版本的文件信息的时候要做到不保存重复数据, 以节约存储空间, 提高运行效率. 这方面SVN采用的是增量式管理的方式, 而Git采取了文件系统快照的方式.
4. **权限控制** :
   * 对团队中参与开发的人员进行权限控制.
   * 对团队外开发者贡献的代码进行审核--Git独有.
5. **历史记录** :
   * 查看修改人, 修改时间, 修改内容, 日志信息.
   * 将本地文件恢复到某一个历史状态.
6. **分支管理** :
   * 允许开发团队在工作过程中多条生产线同时推进任务, 进一步提高效率.

**2. [版本控制简介]()**

1. **版本控制** :

   * 工程设计领域中使用版本控制管理工程蓝图的设计过程. 在IT开发过程中也可以使用版本控制思想管理代码的版本迭代.

2. **版本控制工具(两类)** :

   * **集中式版本控制工具** : CVS, SVN, VSS ......

     ![](D:\git&github-figure\2.png)

   * **分布式版本控制工具** : Git, Mercurial, Bazaar, Darcs ......

     ![](D:\git&github-figure\3.png)



#### 三. Git简介

**1. [Git的优势]()**

* 大部分操作在本地完成, 不需要联网;
* 完整性保证;
* 尽可能添加数据而不是删除或修改数据;
* 分支操作非常快捷流畅;
* 与Linux命令全面兼容.

**2. [Git在本地的结构]()**

![](D:\git&github-figure\4.png)

* **工作区** : 写代码;
* **暂存区** : 临时存储;
* **本地库** : 存放历史版本的.

**3. [Git和代码托管中心]()**

1. **代码托管中心的作用** : 维护远程库.
2. **代码托管中心的分类** :
   1. 局域网环境下: GitLab服务器.
   2. 外网环境下: GitHub; 码云.

**4. [本地库和远程库的交互方式]()**

* **团队内部协作场景** :

  ![](D:\git&github-figure\5.png)

* **跨团队协作场景** :

  ![](D:\git&github-figure\6.png)



#### 四. Git命令行操作

**1. [本地库操作]()**

1. **本地库初始化1--初始化** : 

   * 命令 : `git init`

   * 效果 : 

     ![](D:\git&github-figure\7.png)

   * 注意 : `.git`目录中存放的是本地库相关的子目录和文件, 不要删除, 也不要胡乱修改.

2. **本地库初始化2--设置签名** : 

   * 形式 :

     1. 用户名 : tom;
     2. Email地址 : goodMorning@atguigu.com.

   * 作用 : **区分不同开发人员的身份**.

   * 辨析 : 这里设置的签名和登录远程库(代码托管中心)的账号, 密码没有任何关系.

   * 命令 : 

     1. **项目级别/仓库级别** : 仅在当前本地库范围内有效

        * `git config user.name tom_pro`

        * `git config user.email goodMorning_pro@atguigu.com`

        * **信息保存位置** : `./.git/config`文件

          ![](D:\git&github-figure\8.png)

     2. **系统用户级别** : 登录当前操作系统的用户范围

        * `git config --global user.name tom_glb`

        * `git config --global user.email goodMorning_pro@atguigu.com`

        * **信息保存位置** : `~/.gitconfig`文件 (当前用户家目录下的.gitconfig文件)

          ![](D:\git&github-figure\9.png)

     3. **优先级** : 

        * 就近原则 : 项目级别优先于系统用户级别, 二者都有时采用项目级别的签名;
        * 如果只有系统用户级别的签名, 就以系统用户级别的签名为准;
        * 二者都没有不允许.

3. **基本操作** :

   1. **状态查看操作** : `git status` (查看工作区, 暂存区状态)

   2. **添加操作** : `git add [file name]` (将工作区的文件的"新建/修改"添加到暂存区)

   3. **提交操作** : `git commit -m "commit message" [file name]` (将暂存区的内容提交到本地库)

   4. **查看历史记录操作** :  

      * `git log`

        ![](D:\git&github-figure\10.png)

        多屏显示控制方式 :

        * 空格向下翻页;
        * b向上翻页;
        * q退出.

      * `git log --pretty=oneline`

        ![](D:\git&github-figure\11.png)

        HEAD是一个指针, 指向当前所在的版本.

      * `git log --oneline`

        ![](D:\git&github-figure\12.png)

      * `git reflog`

        ![](D:\git&github-figure\13.png)

        HEAD@{移动到当前版本需要多少步}

   5. **前进后退历史版本** :

      * 前进后退历史版本操作的本质:

        ![](D:\git&github-figure\14.png)

      * **基于索引值的方式(推荐)** : `git reset --hard [局部索引值]`

      * **使用^符号的方式** : 只能往后退.

        * `git reset --hard HEAD^`
        * 注意: 一个^表示后退一步, n个^表示后退n步.

      * **使用~符号的方式** : 只能往后退.

        * `git reset --hard HEAD~n`
        * 注意: 表示后退n步.

      * **hard和soft以及mixed参数对比** : 

        * `--hard参数` : 在本地库移动HEAD指针; 重置暂存区; 重置工作区.

          ![](D:\git&github-figure\17.png)

        * `--soft参数` : 仅仅在本地库移动HEAD指针.

          ![](D:\git&github-figure\15.png)

        * `--mixed参数` : 在本地库移动HEAD指针; 重置暂存区.

          ![](D:\git&github-figure\16.png)

   6. **删除文件并找回** :

      * **前提** : 删除前, 文件存在时的状态提交到了本地库.
      * **操作** : `git reset --hard [指针位置]`
        1. 删除操作已经提交到本地库: **指针位置指向历史记录**;
        2. 删除操作尚未提交到本地库: **指针位置使用HEAD**.

   7. **比较文件差异** :

      * `git diff [文件名]` : 将工作区中的文件和暂存区进行比较.
      * `git diff [本地库中的历史版本] [文件名]` : 将工作区中的文件和本地库历史记录比较.
      * **不带文件名比较多个文件**.

4. **分支管理** :

   ![](D:\git&github-figure\18.png)

   1. **什么是分支?**
      
      * 在版本控制过程中, 使用多条线同时推进多个任务.
   2. **分支的好处?**
      * 同时并行推进多个功能开发, 提高开发效率;
      * 各个分支在开发过程中, 如果某一个分支开发失败, 不会对其他分支有任何影响. 失败的分支删除重新开始即可.
   3. **分支操作** :
      * **创建分支** : `git branch [分支名]`
      
      * **查看分支** : `git branch -v`
      
      * **切换分支** : `git checkout [分支名]`
      
      * **合并分支** :
      
        1. 第一步: **切换到接受修改的分支(被合并, 增加新内容)上** `git checkout [被合并的分支名]`;
        2. 第二步: **执行merge命令** `git merge [有新内容的分支名]`.
      
      * **解决冲突** :
      
        1. **冲突的表现** :
      
           ![](D:\git&github-figure\19.png)
      
        2. **冲突的解决** :
      
           * 第一步: **编辑文件, 删除特殊符号**;
           * 第二步: **把文件修改到满意的程度, 保存退出**;
           * 第三步: **git add [文件名]**;
           * 第四步: **git commit -m "日志信息"**.
             * **注意: 此时commit一定不能带具体的文件名**.

**2. [Git基本原理]()**

1. **Hash算法**

   * 说明: 哈希是一个系列的加密算法, 各个不同的哈密算法虽然加密强度不同, 但是有几个共同特点. **Git底层采用的是SHA-1算法**.

   * 特点: 

     1. 不管输入数据的数据量有多大, 输入同一个哈希算法, 得到的加密结果长度固定;
     2. 哈希算法确定, 输入数据确定, 输出数据能够保证不变;
     3. 哈希算法确定, 输入数据有变化, 输出数据一定有变化, 而且变化通常很大;
     4. 哈希算法不可逆.

   * 应用: 哈希算法可以被用来验证文件. 原理如下图所示.

     ![](D:\git&github-figure\20.png)

     Git就是靠这种机制来从根本上保证数据完整性的.

2. **Git保存版本的机制**

   * **集中式版本控制工具的文件管理机制** : 以文件变更列表的方式存储信息. 这类系统将它们保存的信息看作是一组基本文件和每个文件随时间逐步累积的差异.

     ![](D:\git&github-figure\21.png)

   * **Git的文件管理机制** : Git把数据看作是小型文件系统的一组快照. 每次提交更新时Git都会对当前的全部制作一个快照并保存这个快照的索引. 为了高效, 如果文件没有修改, Git不再重新存储该文件, 而是只保留一个链接指向之前存储的文件. 所以Git的工作方式可以称之为快照流.

     ![](D:\git&github-figure\22.png)

   * **Git文件管理机制的细节** :

     1. Git的"提交对象" :

        ![](D:\git&github-figure\23.png)

     2. 提交对象及其父对象形成的链条 :

        ![](D:\git&github-figure\24.png)

3. **Git分支管理机制**

   * **分支的创建** :

     ![](D:\git&github-figure\25.png)

   * **分支的切换** :

     ![](D:\git&github-figure\26.png)

     ![27](D:\git&github-figure\27.png)

     ![28](D:\git&github-figure\28.png)

     ![29](D:\git&github-figure\29.png)

**3. [远程库操作]()**

1. **账号信息**

2. **创建远程库**

3. **创建远程库地址别名** :

   * `git remote -v` : 查看当前所有远程地址别名;
   * `git remote add [远程仓库地址别名] [远程地址]` : 在本地库保存远程库地址并创建远程库地址别名.

   ![](D:\git&github-figure\31.png)

4. **推送** :

* `git push [远程地址别名] [分支名]`

![](D:\git&github-figure\30.png)

5. **克隆** :

* 命令: `git clone [远程地址]`
* 效果:
  * **完整的把远程库下载到本地**;
  * **创建origin远程地址别名**;
  * **初始化本地库**.

6. **拉取** :
   * `pull = fetch + merge`
   * `git fetch [远程库地址别名] [远程分支别名]`
     * 该命令只是将远程库文件下载下来, 没有合并, 所以看不到有变化的文件, 如果想要看, 要切换分支: `git checkout origin/master`.
   * `git merge [远程库地址别名/远程分支名]`
     * 将从远程库下载下来的文件和本地库合并.
   * `git pull [远程库地址别名] [远程分支名]` 
     * 如果是小的变化, 不会有什么冲突等问题, 则直接使用pull即可; 如果是大的变化, 需要审核, 则采用分开的形式, 先fetch, 审核之后再merge.
7. **协同开发时冲突的解决** :
   * 要点 :
     1. 如果不是基于GitHub远程库的最新版本所做的修改, 不能推送, 必须先拉取.
     2. 拉取下来后如果进入冲突状态, 则按照"分支冲突解决"操作解决即可.
8. **跨团队协作操作** :
   * 第一步 : `Fork`
   * 第二步 : 本地修改, 然后推送到远程; pull requests; 对话.
   * 第三步: 代码审核; 合并代码.
   * 第四步: 将远程库拉取到本地.
9. **关于push时用户名密码的登录** :
   * 如果使用http形式的远程地址, 则当每次在本地库每次push时都需要用户名密码的登录, 但是在 windows10的凭据中, 自动保存了远程地址的用户名密码, 所以不用每次输入. 注意: 如果登录时是不同的账户, 则需要在凭据中删除自动保存的远程地址的用户名密码, 才能在push时登录上正确的用户名密码. 但是如果使用ssh登录, 则就不需要每次登录了.
10. **ssh登录** :
    * 进入当前用户的家目录 : `cd~`
    * 删除.ssh目录 : `rm --rvf .ssh`
    * 运行命令生成.ssh密钥目录 : `ssh-keygan -t rsa -C 邮箱账号`
    * 进入.ssh目录查看文件列表 : `cd .ssh`; `ls -lF`
    * 查看id_rsa.pub文件内容 : `cat id_rsa.pub`
    * 复制id_rsa.pub文件内容, 登录github, 点击用户头像->settings->ssh and gpg keys
    * new ssh key
    * 输入复制的密钥信息
    * 回到git bash创建远程地址别名 : `git remote add origin_ssh 远程的ssh地址`
    * 推送文件进行测试.


#### 五. Git工作流

1. **概念**：
    * 在项目开发过程中使用Git的方式。
2. **分类**：
    * ***集中式工作流***：像SVN一样，集中式工作流以中央仓库作为项目所有修改的单点实体。<u>所有修改都提交到Master这个分支上</u>。这种方式与SVN的主要区别就是开发人员有本地库。Git很多特性并没有用到。
    ![](D:\git&github-figure\32.png)
    * ***GitFlow工作流***：GitFlow工作流通过为功能开发，发布准备和维护<u>设立了独立的分支</u>，让发布迭代过程更流畅。严格的分支模型也为大型项目提供了一些非常必要的结构。
    ![](D:\git&github-figure\33.png)
    * ***Forking工作流***：Forking工作流是在GitFlow基础上，<u>充分利用了Git的Fork和pull request的功能以达到代码审核的目的</u>。更适合安全可靠地管理大团队的开发者，而且能接受不信任贡献者的提交。
    ![](D:\git&github-figure\34.png)
3. **GitFlow工作流详解**：
    * ***分支种类***：
        1. 主干分支master：主要负责管理正在运行的生产环境代码。永远保持与正在运行的生产环境完全一致。
        2. 开发分支develop：主要负责管理正在开发过程中的代码。一般情况下应该是最新的代码。
        3. bug修理分支hotfix：主要负责管理生产环境下出现的紧急修复的代码。从主干分支分出，修理完毕并测试上线后，并回主干分支。并回后，视情况可以删除该分支。
        4. 准生产分支(预发布分支)release：较大的版本上线前，会从开发分支中分出准生产分支，进行最后阶段的集成测试。该版本上线后，会合并到主干分支。生产环境运行一段阶段较稳定后可以视情况删除。
        5. 功能分支feature：为了不影响较短周期的开发工作，一般把中长期开发模块，会从开发分支中独立出来。开发完成后会合并到开发分支。
    * ***GitFlow工作流举例***：
    ![](D:\git&github-figure\35.png)
    * ***分支实战***：
    ![](D:\git&github-figure\36.png)
    * ***具体操作***：
        1. 创建分支；
        2. 切换分支审查代码；
        3. 检出远程新分支；
        4. 切换回master；
        5. 合并分支；
        6. 合并结果；
        7. 合并成功后，把master推送到远程。

#### 六. 在IDEA中使用Git

1. **安装Git核心程序**
2. **全局配置**：
    * 在IDEA的version control中<u>配置Git</u>；
    * 在IDEA的version control中<u>配置GitHub</u>。
3. **创建本地库**：
    * 第一步：创建一个maven工程；
    * 第二步：将该maven工程设置为本地库，<u>VCS -> import into version control -> create git repository</u>；
    * 第三步：将不需要添加到暂存区的文件忽略(设置忽略文件)，有以下两种方式。推荐使用第二种。一般将.idea目录，还有其他文件/目录也忽略掉，只留下src目录。(设置所有的.iml文件为忽略文件：`*.iml`)
        1. <u>创建.gitignore文件</u>；
        2. <u>使用项目中自带的一个文件.git/info/exclude进行配置，在IDEA中的位置是Git -> add to .gitignore -> .git/info/exclude</u>。
    * 第四步：添加到暂存区：`Git -> add`；
    * 第五步：添加到本地库：`Git -> Commit Repository`，在工具栏中也有快捷方式。
4. **切换版本**：
    * 查看版本：在工具栏中点击show history，或者`Git -> show history`。
    * 切换版本：点住一个版本 -> 右击 -> copy revision number -> 项目上右键 -> Git -> Repository -> reset head -> hard，粘贴 -> reset。
    * 注意：如果想要回到最新的版本，上述操作失效，要使用git命令，IDEA的terminal就可以使用命令。
5. **创建分支和合并分支**：
    * 创建分支：`Git -> Repository -> Branchs -> new branch`。
    * 合并分支：先切换到master分支(checkout)，然后`Git -> Repository -> merge Branchs`。
    * 注意：项目中看不到是哪个分支，在显示历史版本中才能看到。
6. **解决冲突**：
    * 当发生冲突时，会弹出一个冲突窗口，建议选择merge进行手动合并。
    * 注意：查看当前处于哪个分支：`Git -> Repository -> Branchs`。
7. **上传本地库到GitHub**：
    * 第一步：在github上复制https的url；
    * 第二步：在IDEA中`Git -> Repository -> push -> define remote -> 粘贴到url -> push`。
8. **更新本地库**：
    * `Git -> Repository -> pull`。
9. **从GitHub克隆项目**：
    * 第一步：复制要克隆的项目的url；
    * 第二步：`VCS -> Git -> Clone -> 粘贴url`。
    * 注意：必须是不存在的或者空的文件夹。
    * 重点：如果其他用户要加入团队，要克隆远程库，但是创建远程库人要在github的远程库的settings中将该用户加入到团队中。
10. **SSH免密登录-使用IDEA上传本地库**：
    * 第一步：在github上复制ssh的url；
    * 第二步：在IDEA中`Git -> Repository -> push -> define remote -> 粘贴到url -> push`。

#### 七. Gitlab服务器搭建过程
