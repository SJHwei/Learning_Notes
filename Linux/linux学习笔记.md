# Linux实操篇: vi和vim的使用

## 1. vi和vim的基本介绍

* 所有的Linux系统都会内建vi文本编译器.
* vim具有程序编辑能力, 可以看做vi的增强版本.

## 2. vi和vim常用的三种模式

* 正常模式 : 打开一个文档就直接进入一般模式(默认模式). (`可以在这里使用快捷键`)
* 插入模式 : 按i,I,O,o,A,a,r,R任何一个后进入编辑模式.
* 命令行模式 : 可以使用相关指令, 完成读取, 存盘, ...等的动作.

## 3. vi和vim模式的相互切换

![alt](D:\Markdown-figure\73.png)

## 4. vi和vim的快捷键

* 正常模式 :
  * 拷贝当前行: `yy`, 拷贝当前行向下的5行: `5yy`, 粘贴: `p`.
  * 删除当前行: `dd`, 删除当前行向下的5行: `5dd`.
  * 到文档的最末行: `G`, 到文档的最首行: `gg`.
  * 撤销动作: `u`.
* 命令行模式 : 
  * 在文件中查找某个单词: 命令行下 `/关键字, 回车, 查找`, `输入n就是查找下一个`.
  * 设置文件的行号: `set nu`, 取消文件行号: `set nonu`.
  * 将光标移动到第20行: 
    * 第一步: `set nu`;
    * 第二步: `输入20这个数`;
    * 第三步: `shift+g`.



# Linux实操篇: 用户管理

## 1. 基本介绍

![alt](D:\Markdown-figure\66.png)

* Linux系统是一个多用户多任务的操作系统, 任何一个要使用系统资源的用户, 都必须首先向系统管理员申请一个账号, 然后以这个账号的身份进入系统.
* Linux的用户需要至少要属于一个组.

## 2. 添加用户

* **[useradd [选项] 用户名]()**
* 实例: useradd xm  (默认创建一个与xm同名的组, 并将xm放入这个组中.)
* cd  (表示change directory)(切换目录)
* 细节说明: 
  * 当创建用户成功后, 会自动的创建和用户同名的家目录.
  * 也可以通过`useradd -d 指定目录 新的用户名` , 给新创建的用户指定家目录.

## 3. 指定/修改密码

* **[passwd 用户名]()** 

## 4. 删除用户

* **[userdel 用户名]()**
  * 删除用户xm, 但保留家目录: **[userdel xm]()**
  * 删除用户xh以及用户主目录(家目录): **[userdel -r xh]()**
* 注意1: 上面三个操作都要在root下操作.
* 注意2: 在删除用户时, 一般不会将家目录删除.

## 5. 查询用户信息

* **[id 用户名]()**  (当用户不存在时, 返回无此用户) (wid是用户id号, gid是所在组的id号, 组是组名)

## 6. 切换用户

* **[su - 切换用户名]()**
* 在操作Linux中, 如果当前用户的权限不够, 可以通过su-指令, 切换到高权限用户, 比如root.
* 从高权限用户切换到低权限用户时不需要密码
* 从低权限用户切换到高权限用户时需要密码
* 同级用户之间切换时需要密码
* 进入一个用户后, 如果想要**回到上一个用户**, 使用**exit**.
* 注: 当用户权限不够时, 会给提示.

## 7. 查看当前用户/登录用户

* **[whoami / who am i]()**

## 8. 用户组(类似于公司中组: 开发组, 测试组, ...)

#### 8.1 介绍

​		类似于角色, 系统可以对有共性的多个用户进行统一的管理.

#### 8.2 增加组

* **[groupadd 组名]()**

#### 8.3 删除组

* **[groupdel 组名]()**

#### 8.4 增加用户时直接加上组

* **[useradd -g 用户组 用户名]()**  (创建组, 创建用户并指定组)

#### 8.5 修改用户组

* **[usermod -g 用户组 用户名]()**

#### 8.6 用户和组的相关文件

* **/etc/passwd**文件: 用户的配置文件, 记录用户的各种信息
  * 每行的含义: 用户名 : 口令(密码) : 用户标识号 : 组标识号 : 注释性描述 : 主目录 : 登录shell
* **/etc/shadow**文件: 口令(密码)的配置文件
  * 每行的含义: 登录名 : 加密口令 : 最后一次修改时间 : 最小时间间隔 : 最大时间间隔 : 警告
  * 时间 : 不活动时间 : 失效时间 : 标志
* **/etc/group**文件: 组(group)的配置文件, 记录Linux包含的组的信息.
  * 每行的含义: 组名 : 口令 : 组标识号 : 组内用户列表



# Linux实操篇: 基本指令

## 1. 帮助类

#### 1.1 介绍

​		当对某个指令不熟悉时, 可以使用Linux提供的帮助指令来了解这个指令的使用方法.

#### 1.2 man : 获得帮助信息

* 基本语法 : 
  * `man [命令或配置文件]` (功能描述 : 获得帮助信息)
* 实例 : 
  * man ls

#### 1.3 help : 获得shell内置命令的帮助信息

* 实例 :
  * help cd

#### 1.4 建议

​		当一个指令不熟悉如何学习时, 可以直接百度.

## 2. 文件目录类

#### 2.1 **[pwd]()**

* 显示当前工作目录的绝对路径.

#### 2.2 **[ls]()**

* 基本语法 : `ls [选项] [目录或文件]`
* 常用参数 : 
  * `-a` : 显示所有, 包括隐藏的
  * `-l` : 以列表方式显示信息

#### 2.3 **[cd]()**

* 基本语法 : `cd [参数]`
* 常用参数 : 
  * **绝对路径** : 即从根目录开始定位
  * **相对路径** : 从当前工作目录开始定位到需要的目录
  * `注意` : 使用相对路径时, 需要知道该用户当前在哪个目录下.
* `cd ~ / cd  ` : 回到自己的家目录
* `cd ..` : 回到上级目录

#### 2.4 **[mkdir]()**

* 创建空目录.
* 基本语法 : `mkdir  [选项]  要创建的目录`
* 常见选项 : 
  * `-p` : 创建多级空目录.

#### 2.5 **[rmdir]()**

* 基本语法 : `rmdir  [选项]  要删除的空目录`
* 常见选项 : 
  * `-p` : 删除多级空目录.
* 使用细节 :
  * rmdir删除的是空目录, 如果目录下有内容时无法删除;
  * 提示 : 如果需要删除非空目录, 需要使用`rm -rf  要删除的目录` 命令. 

#### 2.6 **[touch]()**

* 创建文件.
* 基本语法 : `touch  文件名称`  
* 使用细节 : 可以一次性创建多个文件.

#### 2.7 **[cp]()**

* 拷贝文件到指定目录.
* 基本语法 : `cp  [选项]  source(被拷贝的文件)  deat(拷贝到哪里去)`
* 常用选项 : 
  * `-r` : 递归复制整个文件夹
* 应用实例 : 
  * 将/home/aaa.txt拷贝到/home/bbb目录下(拷贝单个文件) : `cp  /home/aaa.txt  /home/bbb/`
  * 将/home/test整个目录拷贝到/home/zwj目录(递归复制整个文件夹) : `cp -r /home/test /home/zwj`
* 注意 : 
  * 一定要知道你当前在哪里, 然后再去用相对路径/绝对路径定位要拷贝的文件夹和拷贝到对应位置的文件夹.
* 使用细节 : 
  * 当再次将同一个目录复制到那个位置时会提示, 目录下有多少个文件就会提示多少次. (即当发现目标目录下有相同文件时, 会提示你是否覆盖.)
  * 强制覆盖不提示的方法 : `\cp`
* 技术小技巧 : 可以通过上下箭头的键调出原来使用过的指令.

#### 2.8 **rm**

* 移除文件或目录.
* 基本语法 : `rm  [选项]  要删除的文件或目录`
* 常用选项 : 
  * `-r` : 递归删除整个文件夹
  * `-f` : 强制删除不提示
* 实例 : 
  * `rm  -rf  bbb/` : 删除目录
  * `rm  bbb.txt` : 删除文件

#### 2.9 **[mv]()**

* 移动文件与目录或重命名.
* 基本语法 : 
  * `mv oldnamefile newnamefile`  (从文件到文件 : 重命名) 
  * `mv /temp/movefile /targetfolder` (从文件到目录 : 移动文件)

#### 2.10 **[cat]()**

* 查看文件内容.
* 基本语法: `cat [选项] 要查看的文件`
* 常用选项: 
  * `-n` : 显示行号
* 使用细节: 
  * cat只能浏览文件, 不能修改文件;
  * cat使用完后直接就退出了, 所以一般要带上 `| more` .
  * cat和more结合使用时, 按空格键就可以显示下一页.

#### 2.11 **[more]()**

* 一个基于VI编辑器的文本过滤器. 它以全屏幕的方式按页显示文本的内容.
* 基本语法: `more 要查看的文件`
* more指令中内置了若干快捷键:
  * 空白键 : 代表向下翻一页;
  * enter: 代表向下翻一行;
  * q: 代表立刻离开more, 不再显示改文本内容;
  * ctrl + f : 向下滚动一屏;
  * ctrl + 8 : 返回上一屏;
  * n : 给出当前行号;
  * f : 输出文件名和当前行的行号.

#### 2.12 **[less]()**

* 用来分屏查看文件内容, 与more类似, 但比more更强大, 支持各种终端显示. less在显示文本内容时, 不是一次将整个文件加载之后才显示, 而是根据显示需要加载的内容, **对显示大型文件具有较高的效率**.
* 基本语法 : `less 要查看的文件`
* 快捷键 : 参考more的快捷键.

#### 2.13 **[> 和 >>]()**

* `>` : 是输出重定向, 会将原来的文件内容覆盖.
* `>>` : 不会覆盖原来文件的内容, 而是追加到文件的尾部.
* 基本语法  :
  * `ls -l > 文件` ： 列表的内容写入文件中（覆盖写）(若该文件不存在, 就创建该文件)
  * `ls -al >> 文件` : 列表的内容追加到文件的末尾
  * `cat 文件1 > 文件2` : 将文件1的内容覆盖到文件2
  * `echo "内容" >> 文件` : 将内容直接追加写入文件中
* 三种类型:
  * 将终端显示的内容加入文件
  * 将一个文件中的内容加入另一个文件
  * 直接将内容加入文件

#### 2.14 **[echo]()**

* 输出内容到控制台.
* 基本语法 : `echo [选项] [输出内容]`
* 输出环境变量(环境路径) : `echo $PATH`

#### 2.15 **[head]()**

* 显示文件的开头部分内容, 默认情况下head指令显示文件的前10行内容.
* 基本语法:
  * `head 文件` : 显示该文件头10行
  * `head -n 5 文件` : 显示该文件头5行

#### 2.16 **[tail]()**

* 用于输出文件中尾部的内容, 默认情况下是后10行.
* 基本语法:
  * `tail 文件`
  * `tail -n 5 文件 ` : 后5行
  * `tail -f 文件` : `实时追踪该文档的所有更新, 按ctrl+c退出`

#### 2.17 **[In]()**

* 软连接指令, 也叫符号链接, 类似于windows里的快捷方式, 主要存放了链接其他文件的路径.
* 基本语法 : 
  * `In -s [原文件目录] [软连接名]` : 给原文件创建了一个软链接.
* 使用细节 :
  * 使用pwd查看路径时, 还是软链接所在目录.
  * **删除软链接**: 不能直接使用rm删除, 因为是指向一个目录的, 所以要这样写: `rm -rf 软链接名`, 如果带`/`, 则认为是删除目录里面的内容, 它不允许.

#### 2.18 **[history]()**

* 查看已经执行过的历史命令, 也可以执行历史命令.
* 基本语法:
  * `history` : 显示全部
  * `history 10` : 显示10个
  * `!178` : 执行178号(历史指令编号)指令.
* 使用细节 : 可以查看在这个系统上执行的历史指令, 可以想向别人学习时用来查看学习.

## 3. 时间日期类

#### 3.1 date : 显示当前日期指令

* 基本语法 : 
  * `date` : 显示当前时间
  * `date +%Y(年)/%m(月)/%d(日)` 
  * `date"+%Y-%m-%d %H: %M: %S"` : 显示年月日时分秒

#### 3.2 date : 设置日期

* 基本语法 : 
  * `date -s 字符串时间`
* 实例 : 
  * `date -s 2020/10/2`
  * `date -s 19:28`

#### 3.3 cal : 查看日历指令

* 基本语法 : 
  * `cal [选项] ` ((不加选项, 显示本月日历))
* 实例 : 
  * `cal 2020` : 显示2020的日历

## 4. 搜索查找类(三种方式)

#### 4.1 **[find]()**

* 从指定目录向下递归地遍历其各个子目录, 将满足条件的文件或目录显示在终端.

* 基本语法: `find [搜索范围] [选项] 对应的搜索要求` 

* 选项说明(三种查询方式):

  * `-name <文件名>`
  * `-user <用户名>`
  * `-size <文件大小>`

* 实例:

  * find /home -name hello.txt
  * find /home -user nobody
  * find / -size +20M  (大于20M)
  * find / -size -20M  (小于20M)
  * find / -size 20M  (等于20M)

* 注意:

  * ctrl + C : 终止运行
  * ls -lh : 可以显示出文件大小
  * k是小写, M是大写

  * 查找 / 目录下所有`.txt`的文件: `find / -name *.txt`  (按照通配符查找)

#### 4.2 **[locate]()**

* 可以快速定位文件路径. locate指令利用事先建立的系统中所有文件名称及路径的locate数据库实现快速定位给定的文件. locate指令无需遍历整个文件系统, 查询速度较快. 为了保证查询结果的准确度, 管理员必须定期更新locate时刻.
* 基本语法: `locate 搜索文件`
* 特别说明: 由于locate指令基于数据库进行查询, 所以第一次运行前, 必须使用updatedb指令创建locate数据库.
* 实例:
  * updatedb
  * locate hello.txt

#### 4.3 **[grep指令和管道符号 | ]()**

* grep过滤查找. **可以在文件内部查找**.
* 管道符 "`|`" : 表示将前一个命令的处理结果输出传递给后面的命令处理. (即在中间做了一个连接, 把两个命令连接起来.)
* 基本语法: `grep [选项] 查找内容 源文件`
* 常用选项: 
  * `-n` : 显示匹配行及行号
  * `-i` : 忽略字母大小写
* 实例: 
  * 在hello.txt中查找"yes"所在行并且显示行号: `cat hello.txt | grep -n yes`

## 5. 压缩和解压类(三种方式)

#### 5.1 **[gzip / gunzip]()** 

* gzip用于压缩文件, gunzip用于解压的.
* 基本语法:
  * `gzip 文件` : 压缩文件, 只能将文件压缩为*.gz文件(`注意:` 压缩后, 不会保留原来的文件);
  * `gunzip 文件.gz` : 解压缩文件命令.

#### 5.2 **[zip / unzip]()**

* zip用于压缩文件, unzip用于解压, 这个命令在项目打包发布中很有用.
* 基本语法:
  * `zip [选项] xxx.zip(要压缩成的文件名, 如果名字前加上路径,即可指定压缩到的地方) 将要压缩的内容` : 压缩文件和目录的命令, 如果是多级目录, 就会压缩多级目录.
  * `unzip [选项] xxx.zip` : 解压缩文件
* 可选参数说明:
  * `-r` : 递归压缩, 即压缩目录(zip常用选项)
  * `-d <目录>` : 指定解压后文件的存放目录(unzip常用选项)
  * 实例: `unzip -d /opt/tmp/ mypackage.zip`

#### 5.3 **[tar]()**

* 即可压缩也可解压, 打包指令, 最后打包后的文件时.tar.gz的文件.
* 基本语法: `tar [选项] xxx.tar.gz 打包的内容` (打包目录, 压缩后的文件格式`.tar.gz`)
* 选项说明:
  * `-C` : 产生`.tar.gz`打包文件;
  * `-V` : 显示详细信息;
  * `-Z` : 打包同时压缩;
  * `-X` : 解包`.tar`文件;
  * `-f` : 指定压缩后的文件名.
* 实例: (-zcvf压缩; -zxvf解压)
  * tar -zcvf a.tar.gz a1.txt a2.txt  (后面可以跟多个文件进行打包压缩)
  * tar -zcvf a.tar.gz /home/
  * tar -zxvf a.tar.gz  (解压到当前目录)
  * tar -zxvf a.tar.gz -C 目录路径(前提: 这个目录必须是存在的)  (解压到指定目录)



# Linux实操篇: 组管理和权限管理

## 1. 组管理

#### 1.1 Linux组基本介绍

​		在Linux中的每个用户必须属于一个组, 不能独立于组外. 在Linux中每个文件有**所有者, 所在组, 其他组**的概念.

![alt](D:\Markdown-figure\65.png)

* 所有者
* 所在组
* 其他组
* 改变用户所在组

#### 1.2 文件/目录所有者

* 一般为文件的创建者, 谁创建了该文件, 就自然成为该文件的所有者. 一般情况下, 用户所在组就是文件所在组.
* 查看文件所有者:
  * 命令: `ls -ahl `
  * 实例: 
    * groupadd police
    * useradd -g police tom
    * passwd tom
    * tom: touch ok.txt
    * ls -ahl
* 修改文件所有者:
  * 命令: `chown 用户名 文件名`  (注意: 文件所有者变了, 但文件所在组没变.)
  * 实例: chown tom apple.txt

#### 1.3 组的创建

* 基本语法: `groupadd 组名`

#### 1.4 文件/目录所在组

* 当某个用户创建了一个文件后, 默认这个文件所在组就是该用户所在的组.
* 查看文件/目录所在组: ls -ahl
* 修改文件所在组: `chgrp 组名 文件名`

#### 1.5 其他组

* **除文件的所有者和所在组的用户外**, 系统的其他用户都是文件的其他组.

#### 1.6 改变用户所在组

* 在添加用户时, 可以指定将该用户添加到哪个组中, 同样的**用root的管理权限**可以改变某个用户的所在组.
* `usermod -g 组名 用户名`
* `usermod -d 目录名 用户名 ` (改变该用户登录的初始目录)

## 2. 权限管理

#### 2.1 权限的基本介绍

* 这儿说的权限主要指的是目录和文件的权限. 

* ls -l 中显示的内容: -rwxrw-- 1 root 1213 Feb 2 09:39 abc
* 实例: -rw-r--r-- 1 tom police 6 3月    18 19:24   ok.txt
  - `-`: 文件的类型, 文件一共有五种类型: `-`(普通文件), `d`(目录), `l`(软链接), `c`(字符设备(键盘, 鼠标)), `b`(块文件(硬盘)). 常见的是普通文件和目录.
  - `rw-`: 表示文件所有者权限(r: 读, w: 写)
  - [注意](): 权限一共有三种: r: 读 w: 写 x: 执行.
  - [注意](): 可以用数字表示上面三种权限: r=4, w=2, x=1. (rwx=7)
  - `r--`: 文件所在组的用户的权限, 只有读的权限.
  - `r--`: 表示文件其他组的用户的权限, 只有读的权限.
  - `1`: 如果最后那个是文件, 表示硬链接的数; 如果是目录, 则表示该目录的子目录个数.
  - `tom`: 文件的所有者.
  - `police`: 文件所在组.
  - `6`: 表示文件的大小, 表示六个字节. 如果是目录, 统一都是4096.
  - `3月  18  19:24`: 表示文件最后的修改时间.
  - `ok.txt`: 文件名.

#### 2.2 rwx权限详解

* **rwx作用到文件**:
  - [r]代表可读: 可以读取, 查看
  - [w]代表可写: 可以修改, 但是不代表可以删除该文件, 删除一个文件的前提条件是对该文件所在的目录有写权限, 才能删除该文件.
  - [x]代表可执行: 可以被执行.
* **rwx作用到目录**:
  - [r]代表可读: 可以读取, ls查看目录内容.
  - [w]代表可写: 可以修改, 目录内创建+删除+重命名目录.
  - [x]代表可执行: 可以进入该目录.

#### 2.3 修改权限-chmod

* **基本说明**: 通过chmod指令, 可以修改文件或者目录的权限.
* **第一种方式: +, -, =变更权限**:  u:所有者, g:所有组, o:其他人, a:所有人(u, g, o的总和).
  * chmod u=rwx,g=rx,o=x 文件目录名
  * chmod o+w 文件目录名 (给其他人增加一个写的权限)
  * chmod a-x 文件目录名 (给所有人减去一个执行的权限)

* **第二种方式: 通过数字变更权限**: r=4, w=2, x=1.
  * 实例: chmod u=rwx,g=rx,o=x 文件目录名
  * 上述实例相当于: chmod 751 文件目录名
  * rwx=7, r-x=4+1=5

#### 2.4 修改文件所有者-chown

* **基本介绍**: 
  * chown newowner file 改变了文件的所有者
  * chown newowner:newgroup file 改变了用户的**所有者和所有组**
  * -R 如果是目录, 则使其下所有子文件或目录**递归**生效
  * 实例: 请将 /home/kkk 目录下所有的文件和目录的所有者都修改为tom.
    * 首先应该使用root操作.
    *  chown -R tom kkk/ (将kkk目录下所有的文件, 包括子目录和子目录下的所有文件, 递归的将文件, 目录的所有者改成tom)

#### 2.5 修改文件所在组-chgrp

* **基本介绍**:
  * chgrp newgroup file 改变了文件的所有组
  * -R 如果是目录, 则使其下所有子文件或目录**递归**生效
  * 实例: chgrp -R bandit /home/kkk



# Linux实操篇: 任务调度基本说明

​		定时任务调度:

![alt](D:\Markdown-figure\62.png)

​		自己要做的事就两样: 写脚本, 配置crontab.

## 1. crond任务调度

​		crontab 进行定时任务的设备.

#### 1.1 概述

​		任务调度是指系统在某个时间执行的特定的命令或程序.

#### 1.2 任务调度分类

* 系统工作 : 有些重要的工作必须周而复始地执行. 如病毒扫描等.
* 个别用户工作 : 个别用户可能希望执行某些程序, 比如对MySQL数据库的备份.

#### 1.3 基本语法

​		contab [选项]

#### 1.4 常用选项

* -e : 编辑crontab定时任务;
* -l : 查询crontab任务;
* -r : 删除当前用户所有的crontab任务.

#### 1.5 快速入门案例(任务要求)

* 设置任务调度文件 : /etc/crontab
* 设置个人任务调度 : 执行crontab -e命令
* 接着输入任务到调度文件, 如: ·/1···· ls -l /etc/ > /tmp/to.txt  (意思是说每小时的每分钟执行ls -l /etc/ > /tmp/to.txt命令)

#### 1.6 参数细节说明

* 五个占位符的说明：
  * 第一个黑点：一小时当中的第几分钟  （0-59）
  * 第二个黑点：一天当中的第几个小时  （0-23）
  * 第三个黑点：一个月当中的第几天  （1-31）
  * 第四个黑点：一年当中的第几个月  （1-12）
  * 第五个黑点：一周当中的星期几  （0-7 0和7代表星期日）
* 特殊符号的说明：
  * · ： 代表任何时间。比如第一个黑点代表一小时中每分钟都执行一次的意思。
  * ， ：代表不连续的时间。比如：“0 8,12,16 · · · 命令”，代表在每天的8点0分，12点0分，16点0分都执行一次命令。
  * — ： 代表连续的时间范围。比如：“0 5 · · 1-6 命令”，代表在周一到周六的凌晨6点0分执行命令。
  * ·/n ： 代表每隔多久之心一次。比如：“·/10 · · · · 命令”，代表每隔10分钟就执行一遍命令。

#### 1.7 步骤如下

* crontab -e
* ·/1···· ls -l /etc/ > /tmp/to.txt
* 当保存退出后就生效
* 在每一分钟都会自动调用上面的命令

#### 1.8 任务调度的应用实例

* 案例: 每隔一分钟, 就将当前的日期信息, 追加到/tmp/mydate文件中

  * 先编写一个文件  /home/mytask1.sh

    date >> /tmp/mydate

  * 给mytask1.sh一个可以执行权限: chmod 744 /hone/mytask1.sh  (`注意`: 如果不给改文件可执行权限, 则文件中的命令是没办法执行的. 只有让它可执行, 系统才能调用它.)

  * crontab -e

  * */1 * * * * /home/mytask1.sh



# Linux实操篇: 磁盘分区

## 1. Linux磁盘分区和挂载

#### 1.1 分区的基础知识

**有两种分区方式**: mbr分区, gtp分区.

* mbr分区的特点:

  * 最多支持四个主分区;

  * 系统只能安装在主分区;

  * 扩展分区要占一个主分区;

  * MBR最大只支持2TB, 但拥有最好的兼容性.

* gtp分区的特点:

  * 支持无线多个主分区(但操作系统可能限制, 比如Windows下最多128个分区.)

  * 最大支持18EB的大容量(1EB=1024PB, 1PB=1024TB)

  * Windows7 64位以后支持gtp.

**Windows下的磁盘分区**: 

![alt](D:\Markdown-figure\1.png)

#### 1.2 Linux分区

* **原理介绍**:

  * Linux来说无论有几个分区, 分给哪一目录使用, 它归根结底就只有一个根目录, 一个独立且唯一的文件结构, Linux中每个分区都是用来组成整个文件系统的一部分.
  * Linux采用了一种叫"载入"的处理方法, 它的整个文件系统中包含了一整套的文件和目录, 且将一个分区和一个目录联系起来. 这是要载入的一个分区将使它的存储空间在一个目录下获得.

  ![alt](D:\Markdown-figure\2.png)

* **硬盘说明**: 

  * Linux硬盘分IDE硬盘和SCSI硬盘, 目前基本上是SCSI硬盘.
  * 对于IDE硬盘, 驱动器标识符为"hdx~", 其中"hd"表明分区所在设备的类型, 这里是指IDE硬盘了. "x"为盘号(a为基本盘, b为基本从属盘, c为辅助主盘, d为辅助从属盘). "~"代表分区, 前四个分区用数字1到4表示, 它们是主分区或扩展分区, 从5开始就是逻辑分区. 例: hda3表示为第一个IDE硬盘上的第三个主分区或扩展分区, hdb2表示为第二个IDE硬盘上的第二个主分区或扩展分区.
  * 对于SCSI硬盘则标识为"sdx~", SCSI硬盘是用"sd"来表示分区所在设备的类型的, 其余则和IDE硬盘的表示方法一样.

* **查看所有设备挂载情况**:

  * 使用 `lsblk` 或者 `lsblk -f` 指令查看当前系统的分区情况(如果想看分区大小, 使用 `lsblk` 指令):

  ![alt](D:\Markdown-figure\3.png)

  ![alt](D:\Markdown-figure\4.png)


#### 1.3 给Linux添加一块新硬盘

* **挂载的经典案例**

  ​	需求是给Linux系统增加一个新的硬盘, 并且挂载到/home/newdisk.

  ![alt](D:\Markdown-figure\5.png)

* **如何增加一块硬盘**

  * 第一步: **虚拟机添加硬盘**: 在虚拟机菜单中, 选择设置, 然后设备列表里添加硬盘, 然后一路下一步, 中间只有选择磁盘大小的地方需要修改, 直到完成, 然后重启系统(才能识别)!

  * 第二步: **分区**: 分区命令 `fdisk /dev/sdb` , 开始对/sdb分区

    * m 显示命令列表
    * p 显示磁盘分区 同fdisk -l
    * n 新增分区
    * d 删除分区
    * w 写入并退出

    说明: 开始分区后输入n, 新增分区, 然后选择类型为主分区. 两次回车默认剩余全部空间. 最后输入w写入分区并退出. 若不保存退出输入q.

  * 第三步: **格式化磁盘**: 命令 `mkfs -t ext4 /dev/sdb1` , 其中ext4是分区类型.

  * 第四步: **挂载**: 将一个分区与一个目录联系起来. (mount 设备名称 挂载目录 : 例如 mount /dev/sdb1 /newdisk) (umount 设备名称 或者 挂载目录 : 例如 umount /dev/sdb1 或者 umount /newdisk) (**`用命令行挂载重启后会失败, 所以可以设置为永久挂载(第五步).`**) 

  * 第五步: **设置可以自动挂载(永久挂载)**: 通过修改/etc/fstab实现挂载, 添加完成后执行mount -a即刻生效.

    ![alt](D:\Markdown-figure\6.png)

## 2. 磁盘查询实用指令

#### 2.1 磁盘情况查询

* **查询系统整体磁盘使用情况**: df -lh
* **查询指定目录的磁盘占用情况**: du -h /目录 . 默认为当前目录. (实例: du -ach --max-depth=1 /opt)
  * **-s**: 指定目录占用大小汇总
  * **-h**: 带计量单位
  * **-a**: 含文件
  * **--max-depth=1**: 子目录深度
  * **-c**: 列出明细的同时, 增加汇总值

* **磁盘情况-工作实用指令**: 

  * 统计/home文件夹下文件的个数

    **ls -l /home | grep "^-" | WC -l** (先列出来, 然后过滤, 最后统计)

  * 统计/home文件夹下目录的个数

    **ls -l /home | grep "^d" | WC -l** (先列出来, 然后过滤, 最后统计)

  * 统计/home文件夹下文件的个数, 包括子文件夹里的

    **ls -lR /home | grep "^-" | WC -l** (先列出来, 然后过滤, 最后统计) (R表示递归统计)

  * 统计文件夹下目录的个数, 包括子文件夹里的

    **ls -lR /home | grep "^d" | WC -l** (先列出来, 然后过滤, 最后统计) (R表示递归统计)

  * 以树状显示目录结构

    * 先用 **`yum install tree`** 安装tree指令 (当需要安装一个指令时, 可以使用yum来安装)
    * **tree /** (从根目录开始显示树状目录结构)



# Linux实操篇: 网络配置

​		注意: 在Linux中, 点击网络连接那种方式不好, 因为那样获得的IP是动态的, 每次可能都不一样. 所以下面会解决Linux连接网络是动态的问题. 

## 1. Linux网络配置的原理图(含虚拟机)

​		目前的网络配置采用的是NAT.

![](D:\Markdown-figure\7.png)

## 2. 查看网络IP和网关

* **查看虚拟网络编辑器**: 虚拟机, 编辑, 虚拟网络编辑器.

* **修改IP地址(修改虚拟网络的IP)**: 在`编辑器`中选中`NAT模式`, 然后在下面`子网`那儿修改. 

* **查看网关(查看虚拟网络的网关)**: 编辑器, NAT模式, NAT设置, 网关. (虚拟网卡和真实网卡要出去都需要一个网关, 要保持两个的网关一致.)

* **查看Windows环境中的VMnet8网络设置**: 

  * 界面查看:

    ![alt](D:\Markdown-figure\8.png)

  * 使用ipconfig查看

* **ping测试主机之间网络连通性**: ping 目的主机  (功能描述: 测试当前服务器是否可以连接目的主机) (实例: ping www.baidu.com)

## Linux网络环境配置

​		有两种方法: 一种是自动获取; 另一种是指定固定的IP.

**第一种方法(自动获取)**: 系统, 首选项, 网络连接, 打开之后点击这个玩意(一块网卡), 点击编辑, 勾选上自动连接. 

* 注意: Linux启动后自动获取IP, 缺点是**每次自动获取的IP地址可能不一样**. 所以这个**不适用于做服务器**, 因为我们服务器的IP需要是固定的. 所以只能当做个人机去用.
* 在Linux中, 每次开机都是红叉, 没有连接网络, 所以每次开机都需要自己点一下, 才能连接网络. 这样很麻烦, 所以需要设置, 使得登录后, 自动获取IP(自动连接网络).

**第二种方法(指定固定的IP)**: 直接修改配置文件来指定IP, 并可以连接到外网(程序员推荐), 编辑 **`vi /etc/sysconfig/network-scripts/ifcfg-eth0 (eth0网卡的配置文件)`** (要求: 将IP地址配置成静态的, IP地址为192.168.184.130)

![alt](D:\Markdown-figure\9.png)

![alt](D:\Markdown-figure\10.png)

![alt](D:\Markdown-figure\11.png)

![alt](D:\Markdown-figure\12.png)

​		配置完之后一定要重启服务: (1) service network restart ; (2) reboot 重启系统.

![alt](D:\Markdown-figure\13.png)



# Linux实操篇: 进程管理

## 1. 进程介绍和查询

#### 1.1 进程的基本介绍

* 在Linux中, 每个执行的**程序(代码)**都称为一个**进程**. 每一个进程都分配一个**ID号**.
* 每一个进程, 都会对应一个**父进程**, 而这个父进程可以**复制多个子进程**. 例如www服务器.
* 每个进程都可能以**两种方式**存在的. **前台和后台**, 所谓前台进程就是用户目前的屏幕上可以进行操作的, 后台进程则是实际在操作, 但由于屏幕上无法看到的进程, 通常使用后台方式执行. (后台进程又称为**守护进程**)
* 一般**系统的服务器**都是以**后台进程**的方式存在, 而且都会**常驻在系统**中, 直到关机才结束.

#### 1.2 **显示系统执行的进程**

* **基本介绍**: **ps命令**用来查看目前系统中, 有哪些正在执行, 以及它们执行的状况. 可以不加任何参数.

  * ps显示的信息选项:

    * PID: 进程识别号
    * TTY: 终端机号
    * TIME: 此进程所消耗CPU时间
    * CMD: 正在执行的命令或进程名

    指令: ps -aux | grep xxx (实例: ps -aux | grep sshd)

    ![alt](D:\Markdown-figure\14.png)

  * ps可选参数说明(一般是三个组合 -aux):

    * ps -a : 显示当前终端的所有进程信息
    * ps -u : 以用户的格式显示进程信息
    * ps -x : 显示后台进程运行的参数

  * 如果想看**父进程**, 使用 **`ps -ef`** 指令. (**PID**: 进程ID; **PPID**: 父进程的ID)

  * 实例: 查看sshd进程的父进程号: ps -ef | grep sshd

## 2. 终止进程

#### 2.1 终止进程kill和killall

* **介绍**: 若是某个进程执行一般需要停止时, 或是已消耗了很大的系统资源时, 此时可以考虑停止该进程. 使用**kill命令**来完成此项任务.

* **基本语法**: 

  * **kill [选项] 进程号** (功能描述, 通过进程号杀死进程)
  * **killall 进程名称** (功能描述: 通过进程名称杀死进程, 也支持**通配符**, 这在系统因负载过大而变得慢时很有用.)

* **常用选项**: -9: 表示强迫进程立即停止.

* **最佳实践**

  * 踢掉某个非法登录用户

    * ps -aux | grep sshd
    * kill 4010

  * 终止远程登录服务sshd, 在适当时候再次重启sshd服务

    * ps -aux | grep sshd

    * kill 3908

    ![alt](D:\Markdown-figure\15.png)

  * 终止多个gedit编辑器 (killall, 通过进程名称来终止进程)

    * killall gedit

  * 强制杀掉一个终端 (只要有一个/bin/bash, 就是一个终端)

    * ps -aux | grep bash
    * kill 4090 (失败)
    * kill -9 4090 (成功)

    ![alt](D:\Markdown-figure\16.png)

#### 2.2 查看进程树pstree

* **基本语法**: pstree [选项] , 可以更加直观的来看进程信息
* **常用选项**: 
  * -p: 显示进程的PID
  * -u: 显示进程的所属用户

## 3. 服务(service)管理

`注意`: 服务一般后面加着d, 例如sshd, firewalld, mysqld等等. 如果不加d, 那就是单纯的进程, 例如firewall(查看防火墙的状态: firewall-cmd --state). 

#### 3.1 介绍

​		服务本质就是**进程**, 但是是**运行在后台**的, 通常都会监听某个端口, 等待其他程序的请求, 比如(MySQL, sshd, 防火墙等), 因此我们又称为**守护进程**, 是Linux中非常重要的知识点. (原理图)

![alt](D:\Markdown-figure\17.png)

#### 3.2 service管理指令

* **systemctl [start | stop | restart | reload | status] 服务名** 
* **在centos7.0以后, 不再实用service, 而是systemctl** 

#### 3.3 实用案例

* 查看当前防火墙的状况, 关闭防火墙和重启防火墙: 

  * systemctl  restart  firewalld

  * systemctl  status  firewalld
  * systemctl  stop  firewalld

#### 3.4 细节讨论

* 关闭或者启用防火墙后, **立即生效**. (**telnet 测试 某个端口**即可)

  ![alt](D:\Markdown-figure\18.png)

  ![alt](D:\Markdown-figure\19.png)

* 这种方式只是**临时生效,** 当重启系统后, 还是回归以前对服务的设置.

* 如果希望设置某个服务自启动或关闭永久生效, 要使用**chkconfig指令**.

#### 3.5 查看服务名

* 方式1: 使用 **setup -> 系统服务** 就可以看到. (打了 * 的说明是自启动的, 按space就可以取消, 按tab就可以退出了系统服务界面了.)
* 方式2: **/etc/init.d/服务名称**

#### 3.6 服务的运行级别(runlevel)

* 查看或者修改默认级别: **`vi /etc/inittab`**
* Linux系统有7种运行级别: **常用的是级别3和5**
  * **运行级别0**: **系统停机状态**, 系统默认运行级别不能设置为0, 否则不能正常启动;
  * **运行级别1**: **单用户工作状态**, root权限, 用户系统维护, 禁止远程登录;
  * **运行级别2**: **多用户状态(没有NFS)**, 不支持网络;
  * **运行级别3**: **完全的多用户状态(有NFS)**, 登录后进入控制台命令行模式;
  * **运行级别4**: 系统未使用, 保留;
  * **运行级别5**: **XII控制台, 登录后进入图形GUI模式**;
  * **运行级别6**: **系统正常关闭并重启**, 默认运行级别不能设为6, 否则不能正常启动.
* 开机的流程说明: **开机 -> BIOS -> /boot -> init进程 -> 运行级别 -> 运行级对应的服务**.

 #### 3.7 chkconfig指令

* **介绍**: 通过chkconfig命令**可以给每个服务的各个运行级别设置自启动/关闭**. (例如: 给各个运行级别设置sshd服务的自启动/关闭.)

  ![alt](D:\Markdown-figure\20.png)

* **基本语法**:

  * 查看服务: chkconfig --list | grep xxx
  * 查看指定服务的各个状态: chkconfig 服务名 --list (和上面的命令效果一样)
  * chkconfig --level 5 服务名 on/off (修改某个服务在某个级别下是否自启动)

* **使用细节**: chkconfig重新设置服务后自启动或关闭, 需要重新启动机器reboot才能生效.

#### 3.8 动态监控进程

* **介绍**: top与ps命令很相似. 它们都用来显示正在执行的进程. top与ps最大的不同之处, 在于top在执行一段时间可以更新正在运行的进程.
* **基本语法**: top [选项]
* **选项说明**: 
  * -d 秒数: 指定top命令每隔几秒更新, 默认是3秒. 在top命令的交互模式当中可以执行的命令.
  * -i : 使top不显示任何闲置或者僵死进程.
  * -p : 通过指定监控进程ID来仅仅监控某个进程的状态.

* **交互操作说明**:
  
  * P : 以CPU使用率排序, 默认就是此项;
  * M : 以内存的使用率排序;
  * N : 以PID排序;
  * q : 退出top.
* **应用实例**:
  
  * 案例1: 监视特定的用户
  
    * top : 输入此命令, 按回车键, 查看执行的进程;
  
      ![alt](D:\Markdown-figure\23.png)
  
    * u : 然后输入"u"回车, 再输入用户名, 即可.
  
  * 案例2: 终止指定的进程
  
    * top : 输入此命令, 按回车键, 查看执行的进程;
    * k : 然后输入"k"回车, 再输入要结束进程的ID号.
  
  * 案例3 : 指定系统状态更新的时间(每隔10秒自动更新, 默认是3秒)
  
    * bash> top -d 10

#### 3.9 监控网络状态

* **查看系统网络情况netstat(重要)(可以看到有哪些外部ip连到你这个服务)(可以监听端口)**:

  * **基本语法**: netstat [选项]  (常用: netstat -anp)

    ![alt](D:\Markdown-figure\24.png)

    ![alt](D:\Markdown-figure\25.png)

  * **选项说明**: 

    * -an : 按一定顺序排列输出
    * -p : 显示哪个进程在调用

  * **应用案例**:

    * 请查看服务名为sshd的服务的信息

* **检测主机连接命令ping**:

  * 是一种**网络检测工具**, 它主要是用**检测远程主机是否正常**, 或是**两部主机间的介质是否为断**, **网线是否脱落或网卡故障**.
  * 如: ping对方ip地址.

#### 3.10 防火墙的相关命令

* **查看firewall的状态** : firewall-cmd --state
* **查看firewall规则** : firewall-cmd --lsit-all
* **查询8080端口是否开放** : firewall-cmd --query-port=8080/tcp
* **开放80端口** : firewall-cmd --permanent --add-port=80/tcp
* **移除8080端口** : firewall-cmd --permanent --remove-port=8080/tcp
* **查看开放了哪些端口** : firewall-cmd --list-ports
* **重启防火墙** : firewall-cmd --reload



# Linux实操篇: RPM与YUM

## 1. RPM包的管理

#### 1.1 介绍

​		一种**用于互联网下载包的打包及安装工具**, 它包含在**某些Linux分发版**中. 它生成具有.RPM扩展名的文件. RPM是redhat package manager(redhat软件包管理工具)的缩写, 类似Windows的setup.exe, 这一文件格式名称虽然打上了redhat的标志, 但理念是通用的.

​		Linux的分发版本都有采用(**suse, redhat, cnetos**等等), 可以算是公认的行业标准了.

#### 1.2 RPM的简单查询指令

​		查询已安装的RPM列表: rpm -qa | grep xx(软件名称)  (查询到的结果就是下面的RPM包名.)

![alt](D:\Markdown-figure\26.png)

#### 1.3 RPM包名基本格式

​		一个RPM包名: firefox-45.0.1-el6.centos.x86_64.rpm

* 名称: firefox
* 版本号: 45.0.1-1
* 使用操作系统: el6.centos.x86_64  (表示centos6.x的64位系统, 如果是i686, i386表示32位系统, noarch表示通用.)

#### 1.4 RPM包的其他查询指令

* **rpm -qa** : 查询所安装的所有rpm软件包

* **rpm -qa | more**

* **rpm -qa | grep X [rpm -qa | grep firefox]**

  

* **rpm -q 软件包名** : 查询软件包是否安装

* **rpm -q firefox**

  

* **rpm -qi 软件包名** : 查询软件包信息

* **rpm -qi filefox**

  ![alt](D:\Markdown-figure\27.png)

  

* **rpm -ql 软件包名** : 查询软件包中的文件

* **rpm -ql firefox**

  ![alt](D:\Markdown-figure\28.png)

  

* **rpm -qf 文件全路径名** : 查询文件所属的软件包

* **rpm -qf /etc/passwd**

  ![alt](D:\Markdown-figure\29.png)

* **rpm -qf /root/install.log**

#### 1.5  卸载RPM包

* **基本语法** : rpm -e RPM包的名称
* **应用案例** :
  * 删除firefox软件包
* **细节讨论** : 
  * 如果其他软件包依赖于您要卸载软件包, 卸载时则会产生错误信息. 如: $ rpm -e foo
  * 如果是我们就是要删除foo这个rpm包, 可以增加参数**--nodeps**, 就可以**强制删除**, 包是一般不推荐这样做, 因为依赖于该软件包的程序可能无法运行. 如: $ rpm -e --nodeps foo 

#### 1.6 安装RPM包

* **基本语法**: rpm -ivh RPM包全路径名称

* **参数说明**: 

  * i : install  安装
  * v : verbose  提示
  * h : hash  进度条

* **应用实例**:

  * 演示卸载和安装firefox浏览器. 

    * 步骤1: 先找到firefox的安装rpm包, 需要挂载上我们安装cnetos的iso文件, 然后到/media/下去找rpm包. (在media下的package中) 

    * **`注意`: 首先,设置虚拟机让它加载iso镜像文件到CD/DVD设备中, 这个设备对应于Linux下的/dev/cdrom文件; 然后在命令行下进行设备的挂载到目录, 一般来说iso镜像文件都挂载到目录/media下(mount /dev/cdrom /media); 之后复制要安装的rpm包到opt下, 进行安装; 最后进行卸载的操作, 将设备cdrom内的内容从/media目录下卸载下来(umount /dev/cdrom).**

    * 步骤2: **cp firefox...(包名) /opt/**  (一般不直接在光驱中安装, 要复制到/opt/下, 然后再安装.)
    
      ![alt](D:\Markdown-figure\30.png)

## 2. YUM

#### 2.1 介绍

​		yum是一个**shell前段软件包管理器**. 基于**RPM**包管理, 能够**从指定的服务器自动下载RPM包并且安装**, 可以**自动处理依赖性关系**, 并且**一次安装所有依赖的软件包**. (使用yum的前提是**可以联网**.)

![alt](D:\Markdown-figure\31.png)

#### 2.2 yum的基本指令

* 查询yum服务器是否有需要安装的软件: **yum list | grep xx软件列表**
* 安装指定的yum包: **yum install xxx**  下载安装

#### 2.3 yum应用实例

* 案例: 请使用yum的方式来安装firefox

  * 步骤1: 先查看一下firefox rpm在yum服务器上有没有

    ![alt](D:\Markdown-figure\32.png)

  * 步骤2: 安装: yum install firefox  (会安装最新版本的软件.)

    ![alt](D:\Markdown-figure\33.png)

## 3. 查看安装软件的路径(位置)

* **whereis XXX** (实例: whereis firefox)



# JavaEE定制篇: JDK安装和配置

![alt](D:\Markdown-figure\34.png)

## 1. 概述

​		如果需要在Linux下进行JavaEE的开发, 需要安装图上的四个软件.

## 2. 安装JDK

* **安装步骤** : 

  * 先将软件通过xftp5上传到/opt下

  * 解压缩到/opt

  * 配置环境变量的配置文件vim /etc/profile

    ![alt](D:\Markdown-figure\35.png)

  * JAVA_HOME=/opt/jdk1.7.0_79

  * PATH=/opt/jdk1.7.0_79/bin:$PATH

  * export JAVA_HOME PATH

  * `注意` : **需要注销用户, 环境变量才能生效.** 如果是在 3 运行级别, 直接使用logout命令; 如果是在 5 运行级别,

  * 在任何目录下就可以使用java和javac.

* **测试是否安装成功** : 编写一个简单的Hello.java  输出"hello world!"

  ![alt](D:\Markdown-figure\36.png)



# JavaEE定制篇: Tomcat安装和配置

## 1. tomcat的安装

![alt](D:\Markdown-figure\42.png)

#### 1.1 步骤

* 解压缩到/opt

  ![alt](D:\Markdown-figure\37.png)

* 启动tomcat ./startup.sh  (先进入到tomcat的bin目录, 如果不想切进去, 配个环境变量就行了.)

  ![alt](D:\Markdown-figure\38.png)

  Linux本地可以通过8080端口访问tomcat, 而windows不能通过Linux访问8080端口, 因为防火墙挡住了8080端口, 只开放了22端口.

* 开放端口8080, 这样外网才能访问到tomcat

  * vim /etc/sysconfig/iptables

  ![](D:\Markdown-figure\39.png)

  **重启防火墙**

  如何打开一个端口:

  ![alt](D:\Markdown-figure\40.png)

#### 1.2 测试是否安装成功:

* 在Windows, Linux下访问 http://linuxip:8080

  ![alt](D:\Markdown-figure\41.png)

## 2. eclipse的安装

#### 2.1 步骤

* 解压缩到/opt

  ![alt](D:\Markdown-figure\43.png)

* 自动eclipse, 配置jre和server
  * 启动方式1: 创建一个快捷方式
  * 启动方式2: 进入到eclipse解压后的文件夹, 然后执行 ./eclipse 即可.
* 编写Hello world程序并测试成功
* 编写jsp页面, 并测试成功

## 3. mysql5.6的安装

#### 3.1 安装的步骤和文档

![alt](D:\Markdown-figure\44.png)

![45](D:\Markdown-figure\45.png)

![46](D:\Markdown-figure\46.png)

![47](D:\Markdown-figure\47.png)

![48](D:\Markdown-figure\48.png)

![49](D:\Markdown-figure\49.png)

![50](D:\Markdown-figure\50.png)

![51](D:\Markdown-figure\51.png)

![52](D:\Markdown-figure\52.png)

![53](D:\Markdown-figure\53.png)

![54](D:\Markdown-figure\54.png)

![55](D:\Markdown-figure\55.png)

![56](D:\Markdown-figure\56.png)

![57](D:\Markdown-figure\57.png)

![58](D:\Markdown-figure\58.png)

![59](D:\Markdown-figure\59.png)

![60](D:\Markdown-figure\60.png)

![61](D:\Markdown-figure\61.png)



# Linux之大数据定制篇

## 1. shell编程

#### 1.1 为什么要学习shell编程

* Linux运维工程师在进行服务器集群管理时, 需要编写shell程序来进行服务器管理.
* 对于javaEE和python程序员来说, 工作的需要, 你的老大一定会要求你编写一些shell脚本进行程序或者服务器的维护, 比如编写一个定时备份数据库的脚本.
* 对于大数据程序员来说, 需要编写shell程序来管理集群.

#### 1.2 shell是什么

* shell是一个命令行解释器, 它为用户提供了一个向Linux内核发送请求以便运行程序的界面系统级程序, 用户可以用shell来启动, 挂起, 停止甚至是编写一些程序.

  ![alt](D:\Markdown-figure\68.png)

#### 1.3 shell脚本的执行方式(shell编程快速入门)

* 脚本格式要求:

  * 脚本以`#!/bin/bash`开头;
  * 脚本需要有`可执行权限`.

* 编写第一个shell脚本:

  * 需求说明: 创建一个shell脚本, 输出hello world!

  ![alt](D:\Markdown-figure\69.png)

* 脚本的常用执行方式:

  * 方式1(输入脚本的**绝对路径**或**相对路径**)

    * 首先要赋予helloworld.sh脚本的+x权限;

    * 执行脚本.

      ![alt](D:\Markdown-figure\70.png)

  * 方式2(sh+脚本) (不推荐)

    * 说明: 不用赋予脚本+x权限, 直接执行即可.

      ![alt](D:\Markdown-figure\71.png)



# Linux nohup 命令

#### 1. nohup命令说明

* nohup命令用于在系统后台不挂断地运行命令, 退出终端不会影响程序的运行. 
* nohup命令, 在默认情况下(非重定向时), 会输出一个名叫nohup.out的文件到当前目录下, 如果当前目录的nohup.out文件不可写, 输出重定向到`$HOME/nohup.out`文件中.

#### 2. 使用权限

* 所有使用者

#### 3. 语法格式

* **[nohup command [arg ...] [&]]()**

#### 4. 参数说明

* command : 要执行的命令
* arg : 一些参数, 可以指定输出文件
* & : 让命令在后台执行, 终端退出后命令仍旧执行

#### 5. 实例

* 在后台执行root目录下的runoob.sh脚本, 并重定向输入到runoob.log文件中:

* **[nohup  /root/runoob.sh  >  runoob.log  2>&1  &]()**
* `2>&1`解释: 将标准错误2重定向到标准输出&1, 标准输出&1再被重定向输入到runoob.log文件中.
  * 0 -- stdin : 标准输入
  * 1 -- stdout : 标准输出
  * 2 -- stderr : 标准错误输出